<h1>Suporte, Manutenção e Reengenharia de Software</h1>

<p>Os conceitos-chave tratados abordam a estratégia de <strong>suporte, manutenção e evolução de software</strong> [1],
    incluindo as técnicas de <strong>engenharia reversa</strong> [2, 3] e <strong>reengenharia</strong> [1, 2, 4] de
    sistemas legados.</p>

<h2>Conceitos-Chave Identificados</h2>

<ul>
    <li><strong>Suporte de Software</strong> [1, 5] e <strong>Suportabilidade</strong> [1, 6]</li>
    <li><strong>Manutenção de Software</strong> [1, 7] (Corretiva, Adaptativa, Perfectiva, Preventiva) [2, 8]</li>
    <li><strong>Manutenibilidade</strong> [1, 9]</li>
    <li><strong>Evolução de Software</strong> [1, 10] e <strong>Reengenharia de Software</strong> [1, 4, 10]</li>
    <li><strong>Leis da Evolução do Software de Lehman</strong> (Mudança Contínua, Complexidade Crescente, Crescimento
        Contínuo, Qualidade em Declínio) [8, 11-15]</li>
    <li><strong>Engenharia Reversa (ER)</strong> [1-3] (Dados, Processamento, Interfaces de Usuário) [1, 16-18]</li>
    <li><strong>Análise Estática</strong> [19] e <strong>Análise Dinâmica</strong> [20] (Técnicas de ER)</li>
    <li><strong>Refatoração</strong> [1, 2, 21, 22] (Código, Dados, Arquitetura) [1, 23-25]</li>
    <li><strong>Engenharia Direta</strong> [1, 26]</li>
    <li><strong>Dívida Técnica</strong> [27, 28]</li>
    <li><strong>Análise de Inventário</strong> [1, 29]</li>
    <li><strong>Reestruturação dos Documentos</strong> [1, 30]</li>
    <li><strong>Análise de Custo-Benefício</strong> (para Reengenharia) [31-34]</li>
</ul>

<hr>

<h2>Resumo Conceitual Conciso e Completo</h2>

<h3>1. Suporte e Manutenção de Software</h3>

<p>O <strong>suporte de software</strong> engloba um conjunto contínuo de atividades que corrige *bugs*, adapta o
    *software* a mudanças no ambiente, melhora-o com base em pedidos dos envolvidos e realiza reengenharia para
    aprimorar funcionalidade e desempenho [5]. O processo de suporte de software começa com a coleta de requisitos e
    termina com a decisão de aposentar o sistema [1]. A <strong>suportabilidade</strong> é a capacidade de fornecer
    suporte a um sistema durante toda sua vida útil, o que implica prover equipamento, infraestrutura, *software*
    adicional, serviços de conveniência e mão de obra necessários para manter o *software* operacional e funcional [6].
</p>

<p>A <strong>manutenção de software</strong> é uma função que corrige defeitos, adapta o *software* a ambientes em
    mudança e melhora a funcionalidade para atender às necessidades dos clientes [7, 10]. A manutenção é uma atividade
    que pode consumir de 60% a 70% de todos os recursos gastos em produtos em uso ativo por muitos anos [35]. A
    <strong>manutenibilidade</strong> é um indicador qualitativo da facilidade de corrigir, adaptar ou melhorar o
    *software* [9].
</p>

<p>Os quatro tipos de manutenção são: <strong>corretiva</strong> (corrige falhas e defeitos),
    <strong>adaptativa</strong> (adapta o *software* às mudanças ambientais), <strong>perfectiva</strong> (adiciona
    novas funcionalidades) e <strong>preventiva</strong> (previne a decadência do sistema) [2, 8]. O <strong>suporte
        proativo</strong> de software é preferível ao conserto reativo, pois exige que os engenheiros antecipem e
    resolvam questões de qualidade antes que se tornem emergências [36-38].
</p>

<h3>2. Evolução e Reengenharia de Software</h3>

<p>O *software* deve ser mantido continuamente e, no momento apropriado, passar por reengenharia para acompanhar o ritmo
    de um ambiente de tecnologia e negócios em rápida mudança [10]. A <strong>evolução do software</strong> por meio da
    reengenharia cria versões de programas existentes com maior qualidade e melhor manutenibilidade [10].</p>

<p>A <strong>Teoria Unificada para a Evolução do Software</strong> (Leis de Lehman) estabelece princípios essenciais
    [14]:
<ol>
    <li>Sistemas implementados em um contexto real devem ser adaptados continuamente (<strong>Lei da Mudança
            Contínua</strong>) [11, 14].</li>
    <li>A complexidade de um sistema aumenta com a evolução, a menos que se trabalhe para mantê-la ou reduzi-la
        (<strong>Lei da Complexidade Crescente</strong>) [12, 14].</li>
    <li>O conteúdo funcional dos sistemas deve ser continuamente ampliado para manter a satisfação do usuário
        (<strong>Lei do Crescimento Contínuo</strong>) [13, 15].</li>
    <li>A qualidade dos sistemas diminuirá se não forem rigorosamente mantidos e adaptados (<strong>Lei da Qualidade em
            Declínio</strong>) [8, 13].</li>
</ol>
A <strong>reengenharia de software</strong> é o processo de usar um sistema existente, frequentemente um **sistema
legado** com **dívida técnica** (custo acumulado de código mal estruturado e más decisões arquiteturais) [2, 28], como
base para gerar um novo sistema com a mesma qualidade de um *software* desenvolvido com práticas modernas [2, 4, 39].
</p>

<p>O processo cíclico de reengenharia [29, 40] inclui as seguintes atividades:
<ul>
    <li><strong>Análise de Inventário:</strong> Avaliação do portfólio de aplicações ativas para selecionar candidatos à
        reengenharia com base em criticidade, longevidade e manutenibilidade [1, 29].</li>
    <li><strong>Reestruturação dos Documentos:</strong> Atualização ou criação de documentação, escolhendo a opção mais
        apropriada para cada caso de sistema legado [1, 30].</li>
    <li><strong>Engenharia Reversa:</strong> (Discutida abaixo) [41].</li>
    <li><strong>Reestruturação/Refatoração do Código:</strong> Análise e modificação do código-fonte para melhorar sua
        estrutura interna [1, 41, 42].</li>
    <li><strong>Reestruturação dos Dados:</strong> Dissecação e reprojeto da arquitetura de dados, o que é uma atividade
        de reengenharia completa e pode resultar em mudanças arquiteturais no programa [43, 44].</li>
    <li><strong>Engenharia Direta:</strong> Utiliza as informações recuperadas do projeto para alterar ou reconstituir o
        sistema, melhorando a qualidade geral e integrando novos requisitos [1, 26]. Se a refatoração for extensa e
        mudar a arquitetura, ela se aproxima da engenharia direta [21, 45].</li>
</ul>
</p>

<p>A decisão de realizar a reengenharia pode ser justificada por uma <strong>Análise de Custo-Benefício</strong>,
    comparando o custo de manutenção continuada, $Cmanut = [P3 − (P1 + P2)] \times L$ (onde P1 é o custo de manutenção
    anual corrente, P2 é o custo de operações anual corrente, P3 é o valor de negócio anual corrente e L é a expectativa
    de vida do sistema) [32, 46], com os custos projetados da reengenharia [32, 34]. O benefício total é calculado por
    $Custo-benefício = Creeng – Cmanut$ [21, 34].</p>

<h3>3. Engenharia Reversa e Análise de Software</h3>

<p>A <strong>Engenharia Reversa (ER)</strong> é o processo de analisar um programa para identificar seus componentes e
    inter-relações e criar representações do sistema em um nível mais elevado de abstração do que o código-fonte [2, 3].
    A ER é um processo de recuperação do projeto [41], essencial para entender o sistema antes de responder a qualquer
    solicitação de manutenção [27].</p>

<p>A ER foca em [1, 16, 47]:
<ul>
    <li><strong>Dados:</strong> Construir diagramas de classe UML e entender estruturas internas de dados (como a
        definição de classes de objetos) e a arquitetura de banco de dados [16, 47, 48].</li>
    <li><strong>Processamento:</strong> Entender e extrair abstrações procedurais em vários níveis (sistema, programa,
        componente), criando diagramas de blocos e narrativas de processamento [17, 47].</li>
    <li><strong>Interfaces de Usuário (UI):</strong> Especificar a estrutura e o comportamento da interface, o que pode
        levar ao desenvolvimento de uma nova metáfora de interação [18, 47, 49, 50].</li>
</ul>
</p>

<p>As técnicas de análise de *software* se dividem em:</p>
<ul>
    <li><strong>Análise Estática:</strong> Análise do *software* sem executá-lo, concentrando-se na estrutura do
        código-fonte, bytecode ou binários [19]. Os objetivos incluem compreender a lógica, identificar vulnerabilidades
        de segurança, detectar padrões de codificação ruins e reconstruir a estrutura do software [19]. Métodos incluem
        a leitura do código-fonte, análise de complexidade de funções (como O(1), O(n), O(n²)) [51-53], análise de
        dependências [54-56] e o uso de ferramentas como SonarQube [57, 58]. A <strong>desmontagem</strong>
        (disassembly) e a <strong>decompilação</strong> são métodos de ER estática aplicados a código binário [59, 60].
    </li>
    <li><strong>Análise Dinâmica:</strong> Análise do comportamento do *software* enquanto ele está em execução [20]. As
        vantagens incluem identificar comportamentos ocultos e descobrir vulnerabilidades que a análise estática pode
        não detectar, sem exigir acesso ao código-fonte, embora exija um ambiente controlado [61]. Métodos incluem
        depuração, monitoramento de chamadas de sistema e análise de memória [61].</li>
</ul>

<h3>4. Refatoração e Reestruturação</h3>

<p>A <strong>refatoração</strong> (*software refactoring*) é o processo de alteração de um sistema de *software* para
    melhorar sua estrutura interna e manutenibilidade sem alterar seu comportamento externo (funcionalidade) [2, 21,
    22]. É usada quando a arquitetura básica é sólida e apenas partes internas exigem retrabalho [23].</p>

<p>A **refatoração de código** gera um projeto com a mesma função, mas com maior qualidade, abordando código
    “emaranhado” [24]. Inclui técnicas como remoção de código duplicado, renomeação de variáveis e métodos,
    encapsulamento de campos e extração de métodos [22, 62-65]. A **refatoração de dados** começa com a engenharia
    reversa para a análise do código-fonte e envolve o reprojeto dos dados, como a padronização de registros de dados e
    a racionalização de nomes de dados [23, 66]. A **refatoração da arquitetura** pode ser considerada para programas
    caóticos, sendo uma das opções (junto com a recodificação de segmentos ou refação completa) para lidar com código
    confuso [25, 67].</p>

<p>A **reestruturação do código** é uma técnica mais ampla que visa ajustar a arquitetura e modularidade [68]. Isso pode
    incluir modularização, conversão de código procedural para orientado a objetos e separação de responsabilidades
    [68-73].</p>